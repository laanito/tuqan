<html>
<head>
    <title>API description</title>
    <link rel="stylesheet" type="text/css" medial="all" title="Default" href="css/help.css"/>
    <style type="text/css">
        div.note {
            margin: 0.5em 0;
        }

        div.class {
            margin: 0.5em 0 0.5em 2em;
        }

        div.interface {
            margin: 1em 0 0.5em 0;
            padding: 2px 5px;
            background-color: #f0f0f0;
        }

        span.interface_name {
            font-weight: bold;
        }

        span.method_name {
            font-weight: bold;
        }
    </style>
</head>
<body>

<h1>Minimal code</h1>
<h2>Using the default pipeline</h2>
<pre class="code">
require_once('pipeline.class.php');
parse_config_file('./.html2ps.config');

$g_config = array(
                  'cssmedia'     => 'screen',
                  'renderimages' => true,
                  'renderforms'  => false,
                  'renderlinks'  => true,
                  'mode'         => 'html',
                  'debugbox'     => false,
                  'draw_page_border' => false
                  );

$media = Media::predefined('A4');
$media->set_landscape(false);
$media->set_margins(array('left'   => 0,
                          'right'  => 0,
                          'top'    => 0,
                          'bottom' => 0));
$media->set_pixels(1024);

$g_px_scale = mm2pt($media->width() - $media->margins['left'] - $media->margins['right']) / $media->pixels;
$g_pt_scale = $g_px_scale * 1.43; 

$pipeline = PipelineFactory::create_default_pipeline("","");
$pipeline->process('http://www.google.com', $media); 
</pre>

<h2>Building your own conversion pipeline</h2>
<pre class="code">
require_once('pipeline.class.php');
parse_config_file('./.html2ps.config');

$g_config = array(
                  'cssmedia'     => 'screen',
                  'renderimages' => true,
                  'renderforms'  => false,
                  'renderlinks'  => true,
                  'mode'         => 'html',
                  'debugbox'     => false,
                  'draw_page_border' => false
                  );

$media = Media::predefined('A4');
$media->set_landscape(false);
$media->set_margins(array('left'   => 0,
                          'right'  => 0,
                          'top'    => 0,
                          'bottom' => 0));
$media->set_pixels(1024);

$g_px_scale = mm2pt($media->width() - $media->margins['left'] - $media->margins['right']) / $media->pixels;
$g_pt_scale = $g_px_scale * 1.43; 

$pipeline = new Pipeline;
$pipeline->fetchers[]     = new FetcherURL;
$pipeline->fetchers[]     = new FetcherLocalFile('./input');
$pipeline->data_filters[] = new DataFilterHTML2XHTML;
$pipeline->parser         = new ParserXHTML;
$pipeline->layout_engine  = new LayoutEngineDefault;
$pipeline->output_driver  = new OutputDriverFPDF($media);
$pipeline->destination    = new DestinationBrowser;

$pipeline->process('http://www.yahoo.com');
</pre>

<h1>Conversion pipeline</h1>
<div>
    <b>PipelineFactory</b> is a simple factory class simplifying building of <b>Pipeline</b> instances;
    <b>create_default_pipeline()</b> will build a simple ready-to-run conversion pipeline. The usage of
    <b>PipelineFactory</b> is not required; you may create the <b>Pipeline</b> object and fill
    the appropriate fields manually.

    <pre class="code">
class PipelineFactory {
  function create_default_pipeline();
}
</pre>
</div>

<div>
    <b>Pipeline</b> class describe the process of conversion as a whole; it contains references to classes, described
    above and is responsible for calling them in correct order and error handling.
    <pre class="code">
class Pipeline {
  var $fetchers;
  var $data_filters;
  var $parser;
  var $pre_tree_filters;
  var $layout_engine;
  var $post_tree_filters;
  var $output_driver;
  var $output_filter;
  var $destination;

  function Pipeline();
  
  function process($data_id);
  function error_message();
}
</pre>
</div>

</div>

<h1>Description of interfaces and classes</h1>

<div class="note">
    Almost all interfaces described below include
    <span class="method_name">error_message</span> method.
    It should return the user-readable description of
    the error. This description MAY contain HTML tags, but should remain
    readable in case tags are removed.
</div>

<div class="interface">
    <p><span class="interface_name">Fetcher</span> interface provides a method of
        fetching the data required
        to build a document tree. Normally, classes implementing this interface would
        fetch an HTML/XHTML string from somewhere (e.g. from remove HTTP server,
        local file or database). Nevertheless, it MAY fetch ANY data provided that
        this data will be understood by parser. The pipeline object may contain
        several fetcher objects; in this case they're used one-by-one until
        one of them return non-null value.</p>

    <p>It is assumed that if you need to get data from non-standard places (e.g. from template engine or database), you
        should implement <span class="interface_name">Fetcher</span> in your own class.</p>

    <p>
        Note that the <b>get_data</b> method returns the <b>FetchedData</b> object (or one of its descendants) instead
        of
        HTML string!
    </p>
</div>

<pre class="code">
class Fetcher {
  function get_data($data_id); 
  function error_message();
}
</pre>
</div>

<div class="class">
    <b>FetcherURL</b> is an implementation of the <b>Fetcher</b> interface.
    Takes the URL and fetches the HTML page using http or https protocol.
    Other protocols considered as an error.

    <pre class="code">
class FetcherURL {
  function FetcherURL();

  function get_data($url);   // fetches the URL and returns the HTML/XHTML content
  function error_message(); 
}
</pre>
</div>

<div class="class">
    <b>FetcherLocalFile</b> is an implementation of the <b>Fetcher</b> interface;
    it reads the contents of local file. As, in general, showing contents of local
    files to user is insecure, we introduce the simple security measure:
    it can fetch only the files inside some predefined directory.

    <pre class="code">
class FetcherLocalFile {
  function FetcherLocalFile($restrict_path);

  function get_data($path);
  function error_message();
}
</pre>
</div>

<div class="interface">
    <B>DataFilter</b> interface describes the filters modifying the raw input data.
    The main purpose of these filters is to fix the raw data so that it can be
    processed by parser without errors.

    <pre class="code">
class DataFilter {
  function process($data);  // returns modified ("filtered") data
  function error_message();
}
</pre>
</div>

<div class="class">
    <b>DataFilterHTML2PSCommands</b> is an implementation of <b>DataFilter</b>.
    It converts the special HTML2PS commands (stricly speaking, the only one &ndash;
    page breaking command, which can be recorded as &lt;!--NewPage--&gt; or
    <?NewPage?>) to HTML "tag" &ndash; &lt;pagebreak/&gt; so that
    XML parser will add this command to the document tree.

    <pre class="code">
class DataFilterHTML2PSCommands {
  function DataFilterHTML2PSCommands();

  function process($data);  // returns modified ("filtered") data
  function error_message();
}
</pre>
</div>

<div class="class">
    <b>DataFilterHTML2XHTML</b> is an implementation of <b>DataFilter</b>.
    The precide description of this filter actions are beyoud the scope of this
    document. In general, it makes the input document a wellformed XML document
    (possibly throwing out invalid parts, by the way). Note that it is achieved
    by extensive use of regular expressions; no XML/HTML parsers involved
    in conversion at this stage.

    <pre class="code">
class DataFilterHTML2XHTML {
  function DataFilterHTML2XHTML();

  function process($data);  // returns modified ("filtered") data
  function error_message();
}
</pre>
</div>

<div class="interface">
    <b>Parser</b> interface provides a method of building the DOM tree from the
    filtered data.

    <pre class="code">
class Parser {
  function process($data);  // returns DOM tree object
  function error_message();
}
</pre>
</div>

<div class="class">
    <b>ParserXHTML</b>

    Implementation of <b>Parser</b> interface; takes an XHTML string as an input
    and returns the dom tree object.

    <pre class="code">
class ParserXHTML {
  function ParserXHTML();

  function process($xhtml); // returns a reference to an object implementing the 
                            // DOMTree interface
}
</pre>
</div>

<div class="interface">
    <b>PreTreeFilter</b> interface describes a procedure of document tree transformation executed before
    the layout engine starts.
    No classes implementing the <b>PreTreeFilter</b> will be included in the distribution
    <pre class="code">
class PreTreeFilter {
  function process(&$tree); // Processes tree IN-PLACE
}
</pre>
</div>

<div class="class">
    <b>PreTreeFilterHTML2PSFields</b> implements <b>PostTreeFilter</b> and describes the processing
    of special fields (such a date, page count, page number, etc.).
    <pre class="code">
class PostTreeFilterHTML2PSFields {
  function PostTreeFilterHTML2PSFields($filename, $filesize, $timestamp);

  function process(&$tree); // Processes tree IN-PLACE
}
</pre>
</div>


<div class="interface">
    <b>LayoutEngine</b> interface of a class processing
    of the document tree and calculating positions of page elements. In theory, different implementations
    of this interface will allow us to use &quot;lightweight&quot; layout engines in case we do
    not need full HTML/CSS support.
    <pre class="code">
class LayoutEngine {
  function process(&$tree, &$media); // Processes tree IN-PLACE
}
</pre>
</div>

<div class="class">
    <b>LayoutEngineDefault</b> - a standard layout engine HTML2PS uses.
    <pre class="code">
class LayoutEngineDefault {
  function LayoutEngineDefault();

  function process(&$tree, &$media); // Processes tree IN-PLACE
}
</pre>
</div>

<div class="interface">
    <b>PostTreeFilter</b> interface describes a procedure of document tree transformation executed after
    the layout engine completes.
    <pre class="code">
class PostTreeFilter {
  function process(&$tree); // Processes tree IN-PLACE
}
</pre>
</div>

<div class="interface"
<b>OutputDriver</b> interface contains device-specific functions - drawing, movement, fonts selection, etc.
In general, description of this interface is beyond the scope of this document, as users are not intended
to implement this interface themselves. Instead, they would use pre-defined output drivers described below.
<pre class="code">
class OutputDriver {
  ...
}
</pre>
</div>

<div class="class">
    <b>OutputDriverPDFLIB</b> implements <b>OutputDriver</b> using PDFLIB.
    <pre class="code">
class OutputDriverPDFLIB {
  function OutputDriverPDFLIB(&$media, $pdf_version);

  ...
}
</pre>
</div>

<div class="class">
    <b>OutputDriverFPDF</b> implements <b>OutputDriver</b> using FPDF
    <pre class="code">
class OutputDriverFPDF {
  function OutputDriverFPDF(&$media, $pdf_version);

  ...
}
</pre>
</div>

<div class="class">
    <b>OutputDriverCompactPS</b> implements <b>OutputDriver</b> for Postscript output.
    <pre class="code">
class OutputDriverCompactPS {
  function OutputDriverCompactPS(&$media);

  ...
}
</pre>
</div>

<div class="interface">
    <b>OutputFilter</b> interface describes the filter applied to generated PS or PDF file.
    <pre class="code">
class OutputFilter {
  function process($temp_filename); // Possibly creates new file and returns its name
}
</pre>
</div>

<div class="class">
    <b>OutputFilterPS2PDF</b> implements <b>OutputFilter</b>. Run the PS2PDF utitity on the generated file.
    <pre class="code">
class OutputFilterPS2PDF {
  function OutputFilterPS2PDF();

  function process($temp_filename);
}
</pre>
</div>

<div class="class">
    <b>OutputFilterGZIP</b> implements <b>OutputFilter</b>. Compresses generated file using ZLIB.
    <pre class="code">
class OutputFilterGZIP {
  function OutputFilterGZIP();

  function process($temp_filename);
}
</pre>
</div>

<div class="interface">
    <b>Destination</b> interface describes the &quot;channel&quot; object which determines where the final output file
    should be placed.
    <pre class="code">
class Destination {
  function process($temp_file_name);
}
</pre>
</div>

<div class="class">
    <b>DestinationBrowser</b> implements <b>Destination</b> and outputs the generated file directly to the browser.
    <pre class="code">
class DestinationBrowser {
  function DestinationBrowser($filename = "");

  function process($temp_file_name);
}
</pre>
</div>

<div class="class">
    <b>DestinationDownload</b> implements <b>Destination</b> and outputs the generated file directly to the browser.
    Unlike <b>DestinationBrowser</b>, this class send headers preventing the file from being opened directly
    in the browser window.
    <pre class="code">
class DestinationDownload {
  function DestinationDownload($filename = "");

  function process($temp_file_name);
}
</pre>
</div>

<div class="class">
    <b>DestinationLocalFile</b> implements <b>Destination</b> and saves generated file on the server side.
    <pre class="code">
class DestinationLocalFile {
  function DestinationLocalFile($dir, $filename = "");
  function process($temp_file_name);
}
</pre>
</div>

<h2>Implementing your own fetcher class</h2>
Sometimes you may need to convert HTML code taken from database or from other non-standard sources.
In this case you should implement <b>Fetcher</b> interface yourself, returning the string to be converted
from the <span class="method_name">get_data</span> method. Additional parameters (like database connection settings,
template variables, etc) may be specified either as globals (not recommended, though), passed as a parameters
to constructor of fetcher object or as $dataId parameter of <span class="method_name">get_data</span> method.

<pre>
class TestFetcher extends Fetcher {
  var $content;
  var $url;

  function get_data($dumb) {
    return new FetchedDataURL($this->content, array(), "");
  }
  
  function set_content($content) {
    $this->content = $content;
  }
}
</pre>

<h1>Class dependencies</h1>
The pipeline object contains the following:
<ul>
    <li>one or more objects implementing <b>Fetcher</b> interface;</li>
    <li>zero or more objects implementing <b>DataFilter</b> interface;</li>
    <li>one object implementing <b>Parser</b> interface;</li>
    <li>zero or more objects implementing <b>PreTreeFilter</b> interface;</li>
    <li>one object implementing <b>LayoutEngine</b> interface;</li>
    <li>zero or more objects implementing <b>PostTreeFilter</b> interface;</li>
    <li>one object implementing <b>OutputDriver</b> interface;</li>
    <li>one object implementing <b>Destination</b> interface;</li>
</ul>

No other dependencies between class in interfaces (except &quot;implements&quot;).

Note that order of filters is important; imagine you're using some king of tree filter which adds header block
containing HTML2PS-specific fields. In this case you must add this filter before PostTreeFilterHTML2PSFields, or
you'll get raw field codes in generated output.

</body>
</html>